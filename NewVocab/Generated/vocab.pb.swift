// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vocab.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Enums
public enum Vocab_Language: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case french // = 0
  case english // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .french
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .french
    case 1: self = .english
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .french: return 0
    case .english: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Vocab_Language] = [
    .french,
    .english,
  ]

}

public enum Vocab_GrammaticalCategory: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case verb // = 0
  case noun // = 1
  case adjective // = 2
  case adverb // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .verb
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .verb
    case 1: self = .noun
    case 2: self = .adjective
    case 3: self = .adverb
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .verb: return 0
    case .noun: return 1
    case .adjective: return 2
    case .adverb: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Vocab_GrammaticalCategory] = [
    .verb,
    .noun,
    .adjective,
    .adverb,
  ]

}

public enum Vocab_LanguageLevel: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case a1 // = 0
  case a2 // = 1
  case b1 // = 2
  case b2 // = 3
  case c1 // = 4
  case c2 // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .a1
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .a1
    case 1: self = .a2
    case 2: self = .b1
    case 3: self = .b2
    case 4: self = .c1
    case 5: self = .c2
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .a1: return 0
    case .a2: return 1
    case .b1: return 2
    case .b2: return 3
    case .c1: return 4
    case .c2: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Vocab_LanguageLevel] = [
    .a1,
    .a2,
    .b1,
    .b2,
    .c1,
    .c2,
  ]

}

public enum Vocab_FrequencyLevel: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case veryCommon // = 0
  case common // = 1
  case uncommon // = 2
  case rare // = 3
  case veryRare // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .veryCommon
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .veryCommon
    case 1: self = .common
    case 2: self = .uncommon
    case 3: self = .rare
    case 4: self = .veryRare
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .veryCommon: return 0
    case .common: return 1
    case .uncommon: return 2
    case .rare: return 3
    case .veryRare: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Vocab_FrequencyLevel] = [
    .veryCommon,
    .common,
    .uncommon,
    .rare,
    .veryRare,
  ]

}

public enum Vocab_FormalityLevel: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case formal // = 0
  case informal // = 1
  case archaic // = 2
  case modern // = 3
  case standard // = 4
  case vulgar // = 5
  case literary // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .formal
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .formal
    case 1: self = .informal
    case 2: self = .archaic
    case 3: self = .modern
    case 4: self = .standard
    case 5: self = .vulgar
    case 6: self = .literary
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .formal: return 0
    case .informal: return 1
    case .archaic: return 2
    case .modern: return 3
    case .standard: return 4
    case .vulgar: return 5
    case .literary: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Vocab_FormalityLevel] = [
    .formal,
    .informal,
    .archaic,
    .modern,
    .standard,
    .vulgar,
    .literary,
  ]

}

public enum Vocab_WordRelationType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case homophone // = 0
  case wordFamily // = 1
  case diminutive // = 2
  case augmentative // = 3
  case collective // = 4
  case compound // = 5
  case synonym // = 6
  case antonym // = 7
  case hypernym // = 8
  case hyponym // = 9
  case UNRECOGNIZED(Int)

  public init() {
    self = .homophone
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .homophone
    case 1: self = .wordFamily
    case 2: self = .diminutive
    case 3: self = .augmentative
    case 4: self = .collective
    case 5: self = .compound
    case 6: self = .synonym
    case 7: self = .antonym
    case 8: self = .hypernym
    case 9: self = .hyponym
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .homophone: return 0
    case .wordFamily: return 1
    case .diminutive: return 2
    case .augmentative: return 3
    case .collective: return 4
    case .compound: return 5
    case .synonym: return 6
    case .antonym: return 7
    case .hypernym: return 8
    case .hyponym: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Vocab_WordRelationType] = [
    .homophone,
    .wordFamily,
    .diminutive,
    .augmentative,
    .collective,
    .compound,
    .synonym,
    .antonym,
    .hypernym,
    .hyponym,
  ]

}

public enum Vocab_Position: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case beforeNoun // = 0
  case afterNoun // = 1
  case both // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .beforeNoun
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .beforeNoun
    case 1: self = .afterNoun
    case 2: self = .both
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .beforeNoun: return 0
    case .afterNoun: return 1
    case .both: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Vocab_Position] = [
    .beforeNoun,
    .afterNoun,
    .both,
  ]

}

public enum Vocab_FrenchGender: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case masculine // = 0
  case feminine // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .masculine
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .masculine
    case 1: self = .feminine
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .masculine: return 0
    case .feminine: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Vocab_FrenchGender] = [
    .masculine,
    .feminine,
  ]

}

public enum Vocab_FrenchMoodName: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case indicatif // = 0
  case conditionnel // = 1
  case subjonctif // = 2
  case imperatif // = 3
  case gerondif // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .indicatif
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .indicatif
    case 1: self = .conditionnel
    case 2: self = .subjonctif
    case 3: self = .imperatif
    case 4: self = .gerondif
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .indicatif: return 0
    case .conditionnel: return 1
    case .subjonctif: return 2
    case .imperatif: return 3
    case .gerondif: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Vocab_FrenchMoodName] = [
    .indicatif,
    .conditionnel,
    .subjonctif,
    .imperatif,
    .gerondif,
  ]

}

public enum Vocab_FrenchTenseName: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case present // = 0
  case imparfait // = 1
  case passeCompose // = 2
  case passeSimple // = 3
  case futurSimple // = 4
  case plusQueParfait // = 5
  case passeAnterieur // = 6
  case futurAnterieur // = 7
  case passe // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .present
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .present
    case 1: self = .imparfait
    case 2: self = .passeCompose
    case 3: self = .passeSimple
    case 4: self = .futurSimple
    case 5: self = .plusQueParfait
    case 6: self = .passeAnterieur
    case 7: self = .futurAnterieur
    case 8: self = .passe
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .present: return 0
    case .imparfait: return 1
    case .passeCompose: return 2
    case .passeSimple: return 3
    case .futurSimple: return 4
    case .plusQueParfait: return 5
    case .passeAnterieur: return 6
    case .futurAnterieur: return 7
    case .passe: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Vocab_FrenchTenseName] = [
    .present,
    .imparfait,
    .passeCompose,
    .passeSimple,
    .futurSimple,
    .plusQueParfait,
    .passeAnterieur,
    .futurAnterieur,
    .passe,
  ]

}

public enum Vocab_FrenchPronoun: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case je // = 0
  case tu // = 1
  case il // = 2
  case elle // = 3
  case on // = 4
  case nous // = 5
  case vous // = 6
  case ils // = 7
  case elles // = 8
  case en // = 9
  case UNRECOGNIZED(Int)

  public init() {
    self = .je
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .je
    case 1: self = .tu
    case 2: self = .il
    case 3: self = .elle
    case 4: self = .on
    case 5: self = .nous
    case 6: self = .vous
    case 7: self = .ils
    case 8: self = .elles
    case 9: self = .en
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .je: return 0
    case .tu: return 1
    case .il: return 2
    case .elle: return 3
    case .on: return 4
    case .nous: return 5
    case .vous: return 6
    case .ils: return 7
    case .elles: return 8
    case .en: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Vocab_FrenchPronoun] = [
    .je,
    .tu,
    .il,
    .elle,
    .on,
    .nous,
    .vous,
    .ils,
    .elles,
    .en,
  ]

}

public enum Vocab_AdverbPosition: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case beginning // = 0
  case afterVerb // = 1
  case endOfSentence // = 2
  case flexible // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .beginning
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .beginning
    case 1: self = .afterVerb
    case 2: self = .endOfSentence
    case 3: self = .flexible
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .beginning: return 0
    case .afterVerb: return 1
    case .endOfSentence: return 2
    case .flexible: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Vocab_AdverbPosition] = [
    .beginning,
    .afterVerb,
    .endOfSentence,
    .flexible,
  ]

}

public enum Vocab_AdverbModifies: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case verb // = 0
  case adjective // = 1
  case adverb // = 2
  case entireSentence // = 3
  case multiple // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .verb
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .verb
    case 1: self = .adjective
    case 2: self = .adverb
    case 3: self = .entireSentence
    case 4: self = .multiple
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .verb: return 0
    case .adjective: return 1
    case .adverb: return 2
    case .entireSentence: return 3
    case .multiple: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Vocab_AdverbModifies] = [
    .verb,
    .adjective,
    .adverb,
    .entireSentence,
    .multiple,
  ]

}

public enum Vocab_FrenchRegion: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case france // = 0
  case quebec // = 1
  case belgium // = 2
  case switzerland // = 3
  case africa // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .france
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .france
    case 1: self = .quebec
    case 2: self = .belgium
    case 3: self = .switzerland
    case 4: self = .africa
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .france: return 0
    case .quebec: return 1
    case .belgium: return 2
    case .switzerland: return 3
    case .africa: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Vocab_FrenchRegion] = [
    .france,
    .quebec,
    .belgium,
    .switzerland,
    .africa,
  ]

}

public enum Vocab_SubjectDomain: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case general // = 0
  case lifestyle // = 1
  case emotions // = 2
  case home // = 3
  case food // = 4
  case animals // = 5
  case aesthetics // = 6
  case temporal // = 7
  case manners // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .general
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .general
    case 1: self = .lifestyle
    case 2: self = .emotions
    case 3: self = .home
    case 4: self = .food
    case 5: self = .animals
    case 6: self = .aesthetics
    case 7: self = .temporal
    case 8: self = .manners
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .general: return 0
    case .lifestyle: return 1
    case .emotions: return 2
    case .home: return 3
    case .food: return 4
    case .animals: return 5
    case .aesthetics: return 6
    case .temporal: return 7
    case .manners: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Vocab_SubjectDomain] = [
    .general,
    .lifestyle,
    .emotions,
    .home,
    .food,
    .animals,
    .aesthetics,
    .temporal,
    .manners,
  ]

}

/// Messages
public struct Vocab_PrepositionRequirement: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var preposition: String = String()

  public var usage: String = String()

  public var example: Vocab_Example {
    get {return _example ?? Vocab_Example()}
    set {_example = newValue}
  }
  /// Returns true if `example` has been explicitly set.
  public var hasExample: Bool {return self._example != nil}
  /// Clears the value of `example`. Subsequent reads from it will return its default value.
  public mutating func clearExample() {self._example = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _example: Vocab_Example? = nil
}

public struct Vocab_WordAttribute: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var word: String {
    get {return _storage._word}
    set {_uniqueStorage()._word = newValue}
  }

  public var englishMeaning: String {
    get {return _storage._englishMeaning}
    set {_uniqueStorage()._englishMeaning = newValue}
  }

  public var ipa: String {
    get {return _storage._ipa}
    set {_uniqueStorage()._ipa = newValue}
  }

  public var examples: [Vocab_Example] {
    get {return _storage._examples}
    set {_uniqueStorage()._examples = newValue}
  }

  public var language: Vocab_Language {
    get {return _storage._language}
    set {_uniqueStorage()._language = newValue}
  }

  public var level: Vocab_LanguageLevel {
    get {return _storage._level}
    set {_uniqueStorage()._level = newValue}
  }

  public var grammaticalCategory: Vocab_GrammaticalCategory {
    get {return _storage._grammaticalCategory}
    set {_uniqueStorage()._grammaticalCategory = newValue}
  }

  public var relatedWords: [Vocab_RelatedWord] {
    get {return _storage._relatedWords}
    set {_uniqueStorage()._relatedWords = newValue}
  }

  public var frequency: Vocab_FrequencyLevel {
    get {return _storage._frequency}
    set {_uniqueStorage()._frequency = newValue}
  }

  public var subjectDomains: [Vocab_SubjectDomain] {
    get {return _storage._subjectDomains}
    set {_uniqueStorage()._subjectDomains = newValue}
  }

  public var formalityLevel: Vocab_FormalityLevel {
    get {return _storage._formalityLevel}
    set {_uniqueStorage()._formalityLevel = newValue}
  }

  public var etymology: Vocab_Etymology {
    get {return _storage._etymology ?? Vocab_Etymology()}
    set {_uniqueStorage()._etymology = newValue}
  }
  /// Returns true if `etymology` has been explicitly set.
  public var hasEtymology: Bool {return _storage._etymology != nil}
  /// Clears the value of `etymology`. Subsequent reads from it will return its default value.
  public mutating func clearEtymology() {_uniqueStorage()._etymology = nil}

  public var culturalNotes: [Vocab_CulturalNote] {
    get {return _storage._culturalNotes}
    set {_uniqueStorage()._culturalNotes = newValue}
  }

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Vocab_Example: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var englishMeaning: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vocab_RelatedWord: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var word: String = String()

  public var englishMeaning: String = String()

  public var example: Vocab_Example {
    get {return _example ?? Vocab_Example()}
    set {_example = newValue}
  }
  /// Returns true if `example` has been explicitly set.
  public var hasExample: Bool {return self._example != nil}
  /// Clears the value of `example`. Subsequent reads from it will return its default value.
  public mutating func clearExample() {self._example = nil}

  public var relationType: Vocab_WordRelationType = .homophone

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _example: Vocab_Example? = nil
}

public struct Vocab_Etymology: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var origin: String = String()

  public var originalWord: String = String()

  public var evolutionSteps: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vocab_CulturalNote: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var note: String = String()

  public var idioms: [String] = []

  public var culturalContext: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vocab_FrenchWordAttribute: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var base: Vocab_WordAttribute {
    get {return _base ?? Vocab_WordAttribute()}
    set {_base = newValue}
  }
  /// Returns true if `base` has been explicitly set.
  public var hasBase: Bool {return self._base != nil}
  /// Clears the value of `base`. Subsequent reads from it will return its default value.
  public mutating func clearBase() {self._base = nil}

  public var regionalUsage: [Vocab_RegionalUsage] = []

  public var pronunciationVariations: [Vocab_PronunciationVariation] = []

  public var falseFriends: [Vocab_FalseFriend] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _base: Vocab_WordAttribute? = nil
}

public struct Vocab_RegionalUsage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var region: Vocab_FrenchRegion = .france

  public var example: Vocab_Example {
    get {return _example ?? Vocab_Example()}
    set {_example = newValue}
  }
  /// Returns true if `example` has been explicitly set.
  public var hasExample: Bool {return self._example != nil}
  /// Clears the value of `example`. Subsequent reads from it will return its default value.
  public mutating func clearExample() {self._example = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _example: Vocab_Example? = nil
}

public struct Vocab_PronunciationVariation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var variation: String = String()

  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vocab_FalseFriend: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var word: String = String()

  public var language: Vocab_Language = .french

  public var englishMeaning: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vocab_FrenchVerb: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var base: Vocab_FrenchWordAttribute {
    get {return _base ?? Vocab_FrenchWordAttribute()}
    set {_base = newValue}
  }
  /// Returns true if `base` has been explicitly set.
  public var hasBase: Bool {return self._base != nil}
  /// Clears the value of `base`. Subsequent reads from it will return its default value.
  public mutating func clearBase() {self._base = nil}

  public var infinitive: String = String()

  public var conjugation: Vocab_FrenchConjugation {
    get {return _conjugation ?? Vocab_FrenchConjugation()}
    set {_conjugation = newValue}
  }
  /// Returns true if `conjugation` has been explicitly set.
  public var hasConjugation: Bool {return self._conjugation != nil}
  /// Clears the value of `conjugation`. Subsequent reads from it will return its default value.
  public mutating func clearConjugation() {self._conjugation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _base: Vocab_FrenchWordAttribute? = nil
  fileprivate var _conjugation: Vocab_FrenchConjugation? = nil
}

public struct Vocab_FrenchConjugation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var moods: [Vocab_FrenchMood] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vocab_FrenchMood: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: Vocab_FrenchMoodName = .indicatif

  public var tenses: [Vocab_FrenchTense] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vocab_FrenchTense: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: Vocab_FrenchTenseName = .present

  public var conjugations: [Vocab_FrenchConjugationForm] = []

  public var example: Vocab_Example {
    get {return _example ?? Vocab_Example()}
    set {_example = newValue}
  }
  /// Returns true if `example` has been explicitly set.
  public var hasExample: Bool {return self._example != nil}
  /// Clears the value of `example`. Subsequent reads from it will return its default value.
  public mutating func clearExample() {self._example = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _example: Vocab_Example? = nil
}

public struct Vocab_FrenchConjugationForm: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pronoun: Vocab_FrenchPronoun = .je

  public var form: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vocab_FrenchNoun: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var base: Vocab_FrenchWordAttribute {
    get {return _base ?? Vocab_FrenchWordAttribute()}
    set {_base = newValue}
  }
  /// Returns true if `base` has been explicitly set.
  public var hasBase: Bool {return self._base != nil}
  /// Clears the value of `base`. Subsequent reads from it will return its default value.
  public mutating func clearBase() {self._base = nil}

  public var masculineForm: Vocab_GenderForm {
    get {return _masculineForm ?? Vocab_GenderForm()}
    set {_masculineForm = newValue}
  }
  /// Returns true if `masculineForm` has been explicitly set.
  public var hasMasculineForm: Bool {return self._masculineForm != nil}
  /// Clears the value of `masculineForm`. Subsequent reads from it will return its default value.
  public mutating func clearMasculineForm() {self._masculineForm = nil}

  public var feminineForm: Vocab_GenderForm {
    get {return _feminineForm ?? Vocab_GenderForm()}
    set {_feminineForm = newValue}
  }
  /// Returns true if `feminineForm` has been explicitly set.
  public var hasFeminineForm: Bool {return self._feminineForm != nil}
  /// Clears the value of `feminineForm`. Subsequent reads from it will return its default value.
  public mutating func clearFeminineForm() {self._feminineForm = nil}

  public var primaryGender: Vocab_FrenchGender = .masculine

  public var isCountable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _base: Vocab_FrenchWordAttribute? = nil
  fileprivate var _masculineForm: Vocab_GenderForm? = nil
  fileprivate var _feminineForm: Vocab_GenderForm? = nil
}

public struct Vocab_GenderForm: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gender: Vocab_FrenchGender = .masculine

  public var singular: String = String()

  public var plural: String = String()

  public var definiteArticle: String {
    get {return _definiteArticle ?? String()}
    set {_definiteArticle = newValue}
  }
  /// Returns true if `definiteArticle` has been explicitly set.
  public var hasDefiniteArticle: Bool {return self._definiteArticle != nil}
  /// Clears the value of `definiteArticle`. Subsequent reads from it will return its default value.
  public mutating func clearDefiniteArticle() {self._definiteArticle = nil}

  public var indefiniteArticle: String {
    get {return _indefiniteArticle ?? String()}
    set {_indefiniteArticle = newValue}
  }
  /// Returns true if `indefiniteArticle` has been explicitly set.
  public var hasIndefiniteArticle: Bool {return self._indefiniteArticle != nil}
  /// Clears the value of `indefiniteArticle`. Subsequent reads from it will return its default value.
  public mutating func clearIndefiniteArticle() {self._indefiniteArticle = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _definiteArticle: String? = nil
  fileprivate var _indefiniteArticle: String? = nil
}

public struct Vocab_FrenchAdjective: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var base: Vocab_FrenchWordAttribute {
    get {return _storage._base ?? Vocab_FrenchWordAttribute()}
    set {_uniqueStorage()._base = newValue}
  }
  /// Returns true if `base` has been explicitly set.
  public var hasBase: Bool {return _storage._base != nil}
  /// Clears the value of `base`. Subsequent reads from it will return its default value.
  public mutating func clearBase() {_uniqueStorage()._base = nil}

  public var masculineForm: Vocab_GenderForm {
    get {return _storage._masculineForm ?? Vocab_GenderForm()}
    set {_uniqueStorage()._masculineForm = newValue}
  }
  /// Returns true if `masculineForm` has been explicitly set.
  public var hasMasculineForm: Bool {return _storage._masculineForm != nil}
  /// Clears the value of `masculineForm`. Subsequent reads from it will return its default value.
  public mutating func clearMasculineForm() {_uniqueStorage()._masculineForm = nil}

  public var feminineForm: Vocab_GenderForm {
    get {return _storage._feminineForm ?? Vocab_GenderForm()}
    set {_uniqueStorage()._feminineForm = newValue}
  }
  /// Returns true if `feminineForm` has been explicitly set.
  public var hasFeminineForm: Bool {return _storage._feminineForm != nil}
  /// Clears the value of `feminineForm`. Subsequent reads from it will return its default value.
  public mutating func clearFeminineForm() {_uniqueStorage()._feminineForm = nil}

  public var defaultPosition: Vocab_AdjectivePosition {
    get {return _storage._defaultPosition ?? Vocab_AdjectivePosition()}
    set {_uniqueStorage()._defaultPosition = newValue}
  }
  /// Returns true if `defaultPosition` has been explicitly set.
  public var hasDefaultPosition: Bool {return _storage._defaultPosition != nil}
  /// Clears the value of `defaultPosition`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultPosition() {_uniqueStorage()._defaultPosition = nil}

  public var comparativeForm: Vocab_ComparisonForms {
    get {return _storage._comparativeForm ?? Vocab_ComparisonForms()}
    set {_uniqueStorage()._comparativeForm = newValue}
  }
  /// Returns true if `comparativeForm` has been explicitly set.
  public var hasComparativeForm: Bool {return _storage._comparativeForm != nil}
  /// Clears the value of `comparativeForm`. Subsequent reads from it will return its default value.
  public mutating func clearComparativeForm() {_uniqueStorage()._comparativeForm = nil}

  public var superlativeForm: Vocab_ComparisonForms {
    get {return _storage._superlativeForm ?? Vocab_ComparisonForms()}
    set {_uniqueStorage()._superlativeForm = newValue}
  }
  /// Returns true if `superlativeForm` has been explicitly set.
  public var hasSuperlativeForm: Bool {return _storage._superlativeForm != nil}
  /// Clears the value of `superlativeForm`. Subsequent reads from it will return its default value.
  public mutating func clearSuperlativeForm() {_uniqueStorage()._superlativeForm = nil}

  public var isIrregularComparison: Bool {
    get {return _storage._isIrregularComparison}
    set {_uniqueStorage()._isIrregularComparison = newValue}
  }

  public var requiresPreposition: Vocab_PrepositionRequirement {
    get {return _storage._requiresPreposition ?? Vocab_PrepositionRequirement()}
    set {_uniqueStorage()._requiresPreposition = newValue}
  }
  /// Returns true if `requiresPreposition` has been explicitly set.
  public var hasRequiresPreposition: Bool {return _storage._requiresPreposition != nil}
  /// Clears the value of `requiresPreposition`. Subsequent reads from it will return its default value.
  public mutating func clearRequiresPreposition() {_uniqueStorage()._requiresPreposition = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Vocab_AdjectivePosition: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var position: Vocab_Position = .beforeNoun

  public var example: Vocab_Example {
    get {return _example ?? Vocab_Example()}
    set {_example = newValue}
  }
  /// Returns true if `example` has been explicitly set.
  public var hasExample: Bool {return self._example != nil}
  /// Clears the value of `example`. Subsequent reads from it will return its default value.
  public mutating func clearExample() {self._example = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _example: Vocab_Example? = nil
}

public struct Vocab_ComparisonForms: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var masculine: String = String()

  public var feminine: String = String()

  public var example: Vocab_Example {
    get {return _example ?? Vocab_Example()}
    set {_example = newValue}
  }
  /// Returns true if `example` has been explicitly set.
  public var hasExample: Bool {return self._example != nil}
  /// Clears the value of `example`. Subsequent reads from it will return its default value.
  public mutating func clearExample() {self._example = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _example: Vocab_Example? = nil
}

public struct Vocab_FrenchAdverb: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var base: Vocab_FrenchWordAttribute {
    get {return _storage._base ?? Vocab_FrenchWordAttribute()}
    set {_uniqueStorage()._base = newValue}
  }
  /// Returns true if `base` has been explicitly set.
  public var hasBase: Bool {return _storage._base != nil}
  /// Clears the value of `base`. Subsequent reads from it will return its default value.
  public mutating func clearBase() {_uniqueStorage()._base = nil}

  public var derivedFromAdjective: Bool {
    get {return _storage._derivedFromAdjective}
    set {_uniqueStorage()._derivedFromAdjective = newValue}
  }

  public var sourceAdjective: String {
    get {return _storage._sourceAdjective}
    set {_uniqueStorage()._sourceAdjective = newValue}
  }

  public var typicalPosition: Vocab_AdverbPosition {
    get {return _storage._typicalPosition}
    set {_uniqueStorage()._typicalPosition = newValue}
  }

  public var modifies: Vocab_AdverbModifies {
    get {return _storage._modifies}
    set {_uniqueStorage()._modifies = newValue}
  }

  public var comparativeForm: Vocab_ComparisonForms {
    get {return _storage._comparativeForm ?? Vocab_ComparisonForms()}
    set {_uniqueStorage()._comparativeForm = newValue}
  }
  /// Returns true if `comparativeForm` has been explicitly set.
  public var hasComparativeForm: Bool {return _storage._comparativeForm != nil}
  /// Clears the value of `comparativeForm`. Subsequent reads from it will return its default value.
  public mutating func clearComparativeForm() {_uniqueStorage()._comparativeForm = nil}

  public var superlativeForm: Vocab_ComparisonForms {
    get {return _storage._superlativeForm ?? Vocab_ComparisonForms()}
    set {_uniqueStorage()._superlativeForm = newValue}
  }
  /// Returns true if `superlativeForm` has been explicitly set.
  public var hasSuperlativeForm: Bool {return _storage._superlativeForm != nil}
  /// Clears the value of `superlativeForm`. Subsequent reads from it will return its default value.
  public mutating func clearSuperlativeForm() {_uniqueStorage()._superlativeForm = nil}

  public var isIrregularComparison: Bool {
    get {return _storage._isIrregularComparison}
    set {_uniqueStorage()._isIrregularComparison = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Vocab_Word: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var wordType: Vocab_Word.OneOf_WordType? = nil

  public var frenchVerb: Vocab_FrenchVerb {
    get {
      if case .frenchVerb(let v)? = wordType {return v}
      return Vocab_FrenchVerb()
    }
    set {wordType = .frenchVerb(newValue)}
  }

  public var frenchNoun: Vocab_FrenchNoun {
    get {
      if case .frenchNoun(let v)? = wordType {return v}
      return Vocab_FrenchNoun()
    }
    set {wordType = .frenchNoun(newValue)}
  }

  public var frenchAdjective: Vocab_FrenchAdjective {
    get {
      if case .frenchAdjective(let v)? = wordType {return v}
      return Vocab_FrenchAdjective()
    }
    set {wordType = .frenchAdjective(newValue)}
  }

  public var frenchAdverb: Vocab_FrenchAdverb {
    get {
      if case .frenchAdverb(let v)? = wordType {return v}
      return Vocab_FrenchAdverb()
    }
    set {wordType = .frenchAdverb(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_WordType: Equatable, Sendable {
    case frenchVerb(Vocab_FrenchVerb)
    case frenchNoun(Vocab_FrenchNoun)
    case frenchAdjective(Vocab_FrenchAdjective)
    case frenchAdverb(Vocab_FrenchAdverb)

  }

  public init() {}
}

public struct Vocab_GetRecentWordsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var words: [Vocab_Word] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vocab_GetRecentWordsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var limit: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "vocab"

extension Vocab_Language: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LANGUAGE_FRENCH"),
    1: .same(proto: "LANGUAGE_ENGLISH"),
  ]
}

extension Vocab_GrammaticalCategory: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GRAMMATICAL_CATEGORY_VERB"),
    1: .same(proto: "GRAMMATICAL_CATEGORY_NOUN"),
    2: .same(proto: "GRAMMATICAL_CATEGORY_ADJECTIVE"),
    3: .same(proto: "GRAMMATICAL_CATEGORY_ADVERB"),
  ]
}

extension Vocab_LanguageLevel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LANGUAGE_LEVEL_A1"),
    1: .same(proto: "LANGUAGE_LEVEL_A2"),
    2: .same(proto: "LANGUAGE_LEVEL_B1"),
    3: .same(proto: "LANGUAGE_LEVEL_B2"),
    4: .same(proto: "LANGUAGE_LEVEL_C1"),
    5: .same(proto: "LANGUAGE_LEVEL_C2"),
  ]
}

extension Vocab_FrequencyLevel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FREQUENCY_LEVEL_VERY_COMMON"),
    1: .same(proto: "FREQUENCY_LEVEL_COMMON"),
    2: .same(proto: "FREQUENCY_LEVEL_UNCOMMON"),
    3: .same(proto: "FREQUENCY_LEVEL_RARE"),
    4: .same(proto: "FREQUENCY_LEVEL_VERY_RARE"),
  ]
}

extension Vocab_FormalityLevel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FORMALITY_LEVEL_FORMAL"),
    1: .same(proto: "FORMALITY_LEVEL_INFORMAL"),
    2: .same(proto: "FORMALITY_LEVEL_ARCHAIC"),
    3: .same(proto: "FORMALITY_LEVEL_MODERN"),
    4: .same(proto: "FORMALITY_LEVEL_STANDARD"),
    5: .same(proto: "FORMALITY_LEVEL_VULGAR"),
    6: .same(proto: "FORMALITY_LEVEL_LITERARY"),
  ]
}

extension Vocab_WordRelationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WORD_RELATION_TYPE_HOMOPHONE"),
    1: .same(proto: "WORD_RELATION_TYPE_WORD_FAMILY"),
    2: .same(proto: "WORD_RELATION_TYPE_DIMINUTIVE"),
    3: .same(proto: "WORD_RELATION_TYPE_AUGMENTATIVE"),
    4: .same(proto: "WORD_RELATION_TYPE_COLLECTIVE"),
    5: .same(proto: "WORD_RELATION_TYPE_COMPOUND"),
    6: .same(proto: "WORD_RELATION_TYPE_SYNONYM"),
    7: .same(proto: "WORD_RELATION_TYPE_ANTONYM"),
    8: .same(proto: "WORD_RELATION_TYPE_HYPERNYM"),
    9: .same(proto: "WORD_RELATION_TYPE_HYPONYM"),
  ]
}

extension Vocab_Position: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POSITION_BEFORE_NOUN"),
    1: .same(proto: "POSITION_AFTER_NOUN"),
    2: .same(proto: "POSITION_BOTH"),
  ]
}

extension Vocab_FrenchGender: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FRENCH_GENDER_MASCULINE"),
    1: .same(proto: "FRENCH_GENDER_FEMININE"),
  ]
}

extension Vocab_FrenchMoodName: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FRENCH_MOOD_NAME_INDICATIF"),
    1: .same(proto: "FRENCH_MOOD_NAME_CONDITIONNEL"),
    2: .same(proto: "FRENCH_MOOD_NAME_SUBJONCTIF"),
    3: .same(proto: "FRENCH_MOOD_NAME_IMPERATIF"),
    4: .same(proto: "FRENCH_MOOD_NAME_GERONDIF"),
  ]
}

extension Vocab_FrenchTenseName: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FRENCH_TENSE_NAME_PRESENT"),
    1: .same(proto: "FRENCH_TENSE_NAME_IMPARFAIT"),
    2: .same(proto: "FRENCH_TENSE_NAME_PASSE_COMPOSE"),
    3: .same(proto: "FRENCH_TENSE_NAME_PASSE_SIMPLE"),
    4: .same(proto: "FRENCH_TENSE_NAME_FUTUR_SIMPLE"),
    5: .same(proto: "FRENCH_TENSE_NAME_PLUS_QUE_PARFAIT"),
    6: .same(proto: "FRENCH_TENSE_NAME_PASSE_ANTERIEUR"),
    7: .same(proto: "FRENCH_TENSE_NAME_FUTUR_ANTERIEUR"),
    8: .same(proto: "FRENCH_TENSE_NAME_PASSE"),
  ]
}

extension Vocab_FrenchPronoun: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FRENCH_PRONOUN_JE"),
    1: .same(proto: "FRENCH_PRONOUN_TU"),
    2: .same(proto: "FRENCH_PRONOUN_IL"),
    3: .same(proto: "FRENCH_PRONOUN_ELLE"),
    4: .same(proto: "FRENCH_PRONOUN_ON"),
    5: .same(proto: "FRENCH_PRONOUN_NOUS"),
    6: .same(proto: "FRENCH_PRONOUN_VOUS"),
    7: .same(proto: "FRENCH_PRONOUN_ILS"),
    8: .same(proto: "FRENCH_PRONOUN_ELLES"),
    9: .same(proto: "FRENCH_PRONOUN_EN"),
  ]
}

extension Vocab_AdverbPosition: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ADVERB_POSITION_BEGINNING"),
    1: .same(proto: "ADVERB_POSITION_AFTER_VERB"),
    2: .same(proto: "ADVERB_POSITION_END_OF_SENTENCE"),
    3: .same(proto: "ADVERB_POSITION_FLEXIBLE"),
  ]
}

extension Vocab_AdverbModifies: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ADVERB_MODIFIES_VERB"),
    1: .same(proto: "ADVERB_MODIFIES_ADJECTIVE"),
    2: .same(proto: "ADVERB_MODIFIES_ADVERB"),
    3: .same(proto: "ADVERB_MODIFIES_ENTIRE_SENTENCE"),
    4: .same(proto: "ADVERB_MODIFIES_MULTIPLE"),
  ]
}

extension Vocab_FrenchRegion: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FRENCH_REGION_FRANCE"),
    1: .same(proto: "FRENCH_REGION_QUEBEC"),
    2: .same(proto: "FRENCH_REGION_BELGIUM"),
    3: .same(proto: "FRENCH_REGION_SWITZERLAND"),
    4: .same(proto: "FRENCH_REGION_AFRICA"),
  ]
}

extension Vocab_SubjectDomain: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUBJECT_DOMAIN_GENERAL"),
    1: .same(proto: "SUBJECT_DOMAIN_LIFESTYLE"),
    2: .same(proto: "SUBJECT_DOMAIN_EMOTIONS"),
    3: .same(proto: "SUBJECT_DOMAIN_HOME"),
    4: .same(proto: "SUBJECT_DOMAIN_FOOD"),
    5: .same(proto: "SUBJECT_DOMAIN_ANIMALS"),
    6: .same(proto: "SUBJECT_DOMAIN_AESTHETICS"),
    7: .same(proto: "SUBJECT_DOMAIN_TEMPORAL"),
    8: .same(proto: "SUBJECT_DOMAIN_MANNERS"),
  ]
}

extension Vocab_PrepositionRequirement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrepositionRequirement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "preposition"),
    2: .same(proto: "usage"),
    3: .same(proto: "example"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.preposition) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.usage) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._example) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.preposition.isEmpty {
      try visitor.visitSingularStringField(value: self.preposition, fieldNumber: 1)
    }
    if !self.usage.isEmpty {
      try visitor.visitSingularStringField(value: self.usage, fieldNumber: 2)
    }
    try { if let v = self._example {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vocab_PrepositionRequirement, rhs: Vocab_PrepositionRequirement) -> Bool {
    if lhs.preposition != rhs.preposition {return false}
    if lhs.usage != rhs.usage {return false}
    if lhs._example != rhs._example {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vocab_WordAttribute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WordAttribute"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "id", json: "_id"),
    2: .same(proto: "word"),
    3: .standard(proto: "english_meaning"),
    4: .same(proto: "ipa"),
    5: .same(proto: "examples"),
    6: .same(proto: "language"),
    7: .same(proto: "level"),
    8: .standard(proto: "grammatical_category"),
    9: .standard(proto: "related_words"),
    10: .same(proto: "frequency"),
    11: .standard(proto: "subject_domains"),
    12: .standard(proto: "formality_level"),
    13: .same(proto: "etymology"),
    14: .standard(proto: "cultural_notes"),
    15: .standard(proto: "created_at"),
    16: .standard(proto: "updated_at"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _word: String = String()
    var _englishMeaning: String = String()
    var _ipa: String = String()
    var _examples: [Vocab_Example] = []
    var _language: Vocab_Language = .french
    var _level: Vocab_LanguageLevel = .a1
    var _grammaticalCategory: Vocab_GrammaticalCategory = .verb
    var _relatedWords: [Vocab_RelatedWord] = []
    var _frequency: Vocab_FrequencyLevel = .veryCommon
    var _subjectDomains: [Vocab_SubjectDomain] = []
    var _formalityLevel: Vocab_FormalityLevel = .formal
    var _etymology: Vocab_Etymology? = nil
    var _culturalNotes: [Vocab_CulturalNote] = []
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _word = source._word
      _englishMeaning = source._englishMeaning
      _ipa = source._ipa
      _examples = source._examples
      _language = source._language
      _level = source._level
      _grammaticalCategory = source._grammaticalCategory
      _relatedWords = source._relatedWords
      _frequency = source._frequency
      _subjectDomains = source._subjectDomains
      _formalityLevel = source._formalityLevel
      _etymology = source._etymology
      _culturalNotes = source._culturalNotes
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._word) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._englishMeaning) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._ipa) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._examples) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._language) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._level) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._grammaticalCategory) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._relatedWords) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._frequency) }()
        case 11: try { try decoder.decodeRepeatedEnumField(value: &_storage._subjectDomains) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._formalityLevel) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._etymology) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._culturalNotes) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._word.isEmpty {
        try visitor.visitSingularStringField(value: _storage._word, fieldNumber: 2)
      }
      if !_storage._englishMeaning.isEmpty {
        try visitor.visitSingularStringField(value: _storage._englishMeaning, fieldNumber: 3)
      }
      if !_storage._ipa.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ipa, fieldNumber: 4)
      }
      if !_storage._examples.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._examples, fieldNumber: 5)
      }
      if _storage._language != .french {
        try visitor.visitSingularEnumField(value: _storage._language, fieldNumber: 6)
      }
      if _storage._level != .a1 {
        try visitor.visitSingularEnumField(value: _storage._level, fieldNumber: 7)
      }
      if _storage._grammaticalCategory != .verb {
        try visitor.visitSingularEnumField(value: _storage._grammaticalCategory, fieldNumber: 8)
      }
      if !_storage._relatedWords.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._relatedWords, fieldNumber: 9)
      }
      if _storage._frequency != .veryCommon {
        try visitor.visitSingularEnumField(value: _storage._frequency, fieldNumber: 10)
      }
      if !_storage._subjectDomains.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._subjectDomains, fieldNumber: 11)
      }
      if _storage._formalityLevel != .formal {
        try visitor.visitSingularEnumField(value: _storage._formalityLevel, fieldNumber: 12)
      }
      try { if let v = _storage._etymology {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._culturalNotes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._culturalNotes, fieldNumber: 14)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vocab_WordAttribute, rhs: Vocab_WordAttribute) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._word != rhs_storage._word {return false}
        if _storage._englishMeaning != rhs_storage._englishMeaning {return false}
        if _storage._ipa != rhs_storage._ipa {return false}
        if _storage._examples != rhs_storage._examples {return false}
        if _storage._language != rhs_storage._language {return false}
        if _storage._level != rhs_storage._level {return false}
        if _storage._grammaticalCategory != rhs_storage._grammaticalCategory {return false}
        if _storage._relatedWords != rhs_storage._relatedWords {return false}
        if _storage._frequency != rhs_storage._frequency {return false}
        if _storage._subjectDomains != rhs_storage._subjectDomains {return false}
        if _storage._formalityLevel != rhs_storage._formalityLevel {return false}
        if _storage._etymology != rhs_storage._etymology {return false}
        if _storage._culturalNotes != rhs_storage._culturalNotes {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vocab_Example: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Example"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .standard(proto: "english_meaning"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.englishMeaning) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if !self.englishMeaning.isEmpty {
      try visitor.visitSingularStringField(value: self.englishMeaning, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vocab_Example, rhs: Vocab_Example) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.englishMeaning != rhs.englishMeaning {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vocab_RelatedWord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RelatedWord"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "word"),
    2: .standard(proto: "english_meaning"),
    3: .same(proto: "example"),
    4: .standard(proto: "relation_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.word) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.englishMeaning) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._example) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.relationType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.word.isEmpty {
      try visitor.visitSingularStringField(value: self.word, fieldNumber: 1)
    }
    if !self.englishMeaning.isEmpty {
      try visitor.visitSingularStringField(value: self.englishMeaning, fieldNumber: 2)
    }
    try { if let v = self._example {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.relationType != .homophone {
      try visitor.visitSingularEnumField(value: self.relationType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vocab_RelatedWord, rhs: Vocab_RelatedWord) -> Bool {
    if lhs.word != rhs.word {return false}
    if lhs.englishMeaning != rhs.englishMeaning {return false}
    if lhs._example != rhs._example {return false}
    if lhs.relationType != rhs.relationType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vocab_Etymology: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Etymology"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "origin"),
    2: .standard(proto: "original_word"),
    3: .standard(proto: "evolution_steps"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.origin) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.originalWord) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.evolutionSteps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.origin.isEmpty {
      try visitor.visitSingularStringField(value: self.origin, fieldNumber: 1)
    }
    if !self.originalWord.isEmpty {
      try visitor.visitSingularStringField(value: self.originalWord, fieldNumber: 2)
    }
    if !self.evolutionSteps.isEmpty {
      try visitor.visitRepeatedStringField(value: self.evolutionSteps, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vocab_Etymology, rhs: Vocab_Etymology) -> Bool {
    if lhs.origin != rhs.origin {return false}
    if lhs.originalWord != rhs.originalWord {return false}
    if lhs.evolutionSteps != rhs.evolutionSteps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vocab_CulturalNote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CulturalNote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "note"),
    2: .same(proto: "idioms"),
    3: .standard(proto: "cultural_context"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.note) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.idioms) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.culturalContext) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.note.isEmpty {
      try visitor.visitSingularStringField(value: self.note, fieldNumber: 1)
    }
    if !self.idioms.isEmpty {
      try visitor.visitRepeatedStringField(value: self.idioms, fieldNumber: 2)
    }
    if !self.culturalContext.isEmpty {
      try visitor.visitSingularStringField(value: self.culturalContext, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vocab_CulturalNote, rhs: Vocab_CulturalNote) -> Bool {
    if lhs.note != rhs.note {return false}
    if lhs.idioms != rhs.idioms {return false}
    if lhs.culturalContext != rhs.culturalContext {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vocab_FrenchWordAttribute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FrenchWordAttribute"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "base"),
    2: .standard(proto: "regional_usage"),
    3: .standard(proto: "pronunciation_variations"),
    4: .standard(proto: "false_friends"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._base) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.regionalUsage) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.pronunciationVariations) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.falseFriends) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._base {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.regionalUsage.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.regionalUsage, fieldNumber: 2)
    }
    if !self.pronunciationVariations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pronunciationVariations, fieldNumber: 3)
    }
    if !self.falseFriends.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.falseFriends, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vocab_FrenchWordAttribute, rhs: Vocab_FrenchWordAttribute) -> Bool {
    if lhs._base != rhs._base {return false}
    if lhs.regionalUsage != rhs.regionalUsage {return false}
    if lhs.pronunciationVariations != rhs.pronunciationVariations {return false}
    if lhs.falseFriends != rhs.falseFriends {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vocab_RegionalUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegionalUsage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "region"),
    2: .same(proto: "example"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.region) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._example) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.region != .france {
      try visitor.visitSingularEnumField(value: self.region, fieldNumber: 1)
    }
    try { if let v = self._example {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vocab_RegionalUsage, rhs: Vocab_RegionalUsage) -> Bool {
    if lhs.region != rhs.region {return false}
    if lhs._example != rhs._example {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vocab_PronunciationVariation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PronunciationVariation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "variation"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.variation) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variation.isEmpty {
      try visitor.visitSingularStringField(value: self.variation, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vocab_PronunciationVariation, rhs: Vocab_PronunciationVariation) -> Bool {
    if lhs.variation != rhs.variation {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vocab_FalseFriend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FalseFriend"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "word"),
    2: .same(proto: "language"),
    3: .standard(proto: "english_meaning"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.word) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.language) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.englishMeaning) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.word.isEmpty {
      try visitor.visitSingularStringField(value: self.word, fieldNumber: 1)
    }
    if self.language != .french {
      try visitor.visitSingularEnumField(value: self.language, fieldNumber: 2)
    }
    if !self.englishMeaning.isEmpty {
      try visitor.visitSingularStringField(value: self.englishMeaning, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vocab_FalseFriend, rhs: Vocab_FalseFriend) -> Bool {
    if lhs.word != rhs.word {return false}
    if lhs.language != rhs.language {return false}
    if lhs.englishMeaning != rhs.englishMeaning {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vocab_FrenchVerb: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FrenchVerb"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "base"),
    2: .same(proto: "infinitive"),
    3: .same(proto: "conjugation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._base) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.infinitive) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._conjugation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._base {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.infinitive.isEmpty {
      try visitor.visitSingularStringField(value: self.infinitive, fieldNumber: 2)
    }
    try { if let v = self._conjugation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vocab_FrenchVerb, rhs: Vocab_FrenchVerb) -> Bool {
    if lhs._base != rhs._base {return false}
    if lhs.infinitive != rhs.infinitive {return false}
    if lhs._conjugation != rhs._conjugation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vocab_FrenchConjugation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FrenchConjugation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "moods"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.moods) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.moods.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.moods, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vocab_FrenchConjugation, rhs: Vocab_FrenchConjugation) -> Bool {
    if lhs.moods != rhs.moods {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vocab_FrenchMood: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FrenchMood"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "tenses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tenses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.name != .indicatif {
      try visitor.visitSingularEnumField(value: self.name, fieldNumber: 1)
    }
    if !self.tenses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tenses, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vocab_FrenchMood, rhs: Vocab_FrenchMood) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.tenses != rhs.tenses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vocab_FrenchTense: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FrenchTense"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "conjugations"),
    3: .same(proto: "example"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.conjugations) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._example) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.name != .present {
      try visitor.visitSingularEnumField(value: self.name, fieldNumber: 1)
    }
    if !self.conjugations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conjugations, fieldNumber: 2)
    }
    try { if let v = self._example {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vocab_FrenchTense, rhs: Vocab_FrenchTense) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.conjugations != rhs.conjugations {return false}
    if lhs._example != rhs._example {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vocab_FrenchConjugationForm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FrenchConjugationForm"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pronoun"),
    2: .same(proto: "form"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.pronoun) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.form) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pronoun != .je {
      try visitor.visitSingularEnumField(value: self.pronoun, fieldNumber: 1)
    }
    if !self.form.isEmpty {
      try visitor.visitSingularStringField(value: self.form, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vocab_FrenchConjugationForm, rhs: Vocab_FrenchConjugationForm) -> Bool {
    if lhs.pronoun != rhs.pronoun {return false}
    if lhs.form != rhs.form {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vocab_FrenchNoun: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FrenchNoun"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "base"),
    2: .standard(proto: "masculine_form"),
    3: .standard(proto: "feminine_form"),
    4: .standard(proto: "primary_gender"),
    5: .standard(proto: "is_countable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._base) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._masculineForm) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._feminineForm) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.primaryGender) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isCountable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._base {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._masculineForm {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._feminineForm {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.primaryGender != .masculine {
      try visitor.visitSingularEnumField(value: self.primaryGender, fieldNumber: 4)
    }
    if self.isCountable != false {
      try visitor.visitSingularBoolField(value: self.isCountable, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vocab_FrenchNoun, rhs: Vocab_FrenchNoun) -> Bool {
    if lhs._base != rhs._base {return false}
    if lhs._masculineForm != rhs._masculineForm {return false}
    if lhs._feminineForm != rhs._feminineForm {return false}
    if lhs.primaryGender != rhs.primaryGender {return false}
    if lhs.isCountable != rhs.isCountable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vocab_GenderForm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenderForm"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gender"),
    2: .same(proto: "singular"),
    3: .same(proto: "plural"),
    4: .standard(proto: "definite_article"),
    5: .standard(proto: "indefinite_article"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.gender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.singular) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.plural) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._definiteArticle) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._indefiniteArticle) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.gender != .masculine {
      try visitor.visitSingularEnumField(value: self.gender, fieldNumber: 1)
    }
    if !self.singular.isEmpty {
      try visitor.visitSingularStringField(value: self.singular, fieldNumber: 2)
    }
    if !self.plural.isEmpty {
      try visitor.visitSingularStringField(value: self.plural, fieldNumber: 3)
    }
    try { if let v = self._definiteArticle {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._indefiniteArticle {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vocab_GenderForm, rhs: Vocab_GenderForm) -> Bool {
    if lhs.gender != rhs.gender {return false}
    if lhs.singular != rhs.singular {return false}
    if lhs.plural != rhs.plural {return false}
    if lhs._definiteArticle != rhs._definiteArticle {return false}
    if lhs._indefiniteArticle != rhs._indefiniteArticle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vocab_FrenchAdjective: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FrenchAdjective"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "base"),
    2: .standard(proto: "masculine_form"),
    3: .standard(proto: "feminine_form"),
    4: .standard(proto: "default_position"),
    5: .standard(proto: "comparative_form"),
    6: .standard(proto: "superlative_form"),
    7: .standard(proto: "is_irregular_comparison"),
    8: .standard(proto: "requires_preposition"),
  ]

  fileprivate class _StorageClass {
    var _base: Vocab_FrenchWordAttribute? = nil
    var _masculineForm: Vocab_GenderForm? = nil
    var _feminineForm: Vocab_GenderForm? = nil
    var _defaultPosition: Vocab_AdjectivePosition? = nil
    var _comparativeForm: Vocab_ComparisonForms? = nil
    var _superlativeForm: Vocab_ComparisonForms? = nil
    var _isIrregularComparison: Bool = false
    var _requiresPreposition: Vocab_PrepositionRequirement? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _base = source._base
      _masculineForm = source._masculineForm
      _feminineForm = source._feminineForm
      _defaultPosition = source._defaultPosition
      _comparativeForm = source._comparativeForm
      _superlativeForm = source._superlativeForm
      _isIrregularComparison = source._isIrregularComparison
      _requiresPreposition = source._requiresPreposition
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._base) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._masculineForm) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._feminineForm) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._defaultPosition) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._comparativeForm) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._superlativeForm) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._isIrregularComparison) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._requiresPreposition) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._base {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._masculineForm {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._feminineForm {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._defaultPosition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._comparativeForm {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._superlativeForm {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._isIrregularComparison != false {
        try visitor.visitSingularBoolField(value: _storage._isIrregularComparison, fieldNumber: 7)
      }
      try { if let v = _storage._requiresPreposition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vocab_FrenchAdjective, rhs: Vocab_FrenchAdjective) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._base != rhs_storage._base {return false}
        if _storage._masculineForm != rhs_storage._masculineForm {return false}
        if _storage._feminineForm != rhs_storage._feminineForm {return false}
        if _storage._defaultPosition != rhs_storage._defaultPosition {return false}
        if _storage._comparativeForm != rhs_storage._comparativeForm {return false}
        if _storage._superlativeForm != rhs_storage._superlativeForm {return false}
        if _storage._isIrregularComparison != rhs_storage._isIrregularComparison {return false}
        if _storage._requiresPreposition != rhs_storage._requiresPreposition {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vocab_AdjectivePosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdjectivePosition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .same(proto: "example"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.position) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._example) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.position != .beforeNoun {
      try visitor.visitSingularEnumField(value: self.position, fieldNumber: 1)
    }
    try { if let v = self._example {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vocab_AdjectivePosition, rhs: Vocab_AdjectivePosition) -> Bool {
    if lhs.position != rhs.position {return false}
    if lhs._example != rhs._example {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vocab_ComparisonForms: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ComparisonForms"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "masculine"),
    2: .same(proto: "feminine"),
    3: .same(proto: "example"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.masculine) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.feminine) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._example) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.masculine.isEmpty {
      try visitor.visitSingularStringField(value: self.masculine, fieldNumber: 1)
    }
    if !self.feminine.isEmpty {
      try visitor.visitSingularStringField(value: self.feminine, fieldNumber: 2)
    }
    try { if let v = self._example {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vocab_ComparisonForms, rhs: Vocab_ComparisonForms) -> Bool {
    if lhs.masculine != rhs.masculine {return false}
    if lhs.feminine != rhs.feminine {return false}
    if lhs._example != rhs._example {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vocab_FrenchAdverb: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FrenchAdverb"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "base"),
    2: .standard(proto: "derived_from_adjective"),
    3: .standard(proto: "source_adjective"),
    4: .standard(proto: "typical_position"),
    5: .same(proto: "modifies"),
    6: .standard(proto: "comparative_form"),
    7: .standard(proto: "superlative_form"),
    8: .standard(proto: "is_irregular_comparison"),
  ]

  fileprivate class _StorageClass {
    var _base: Vocab_FrenchWordAttribute? = nil
    var _derivedFromAdjective: Bool = false
    var _sourceAdjective: String = String()
    var _typicalPosition: Vocab_AdverbPosition = .beginning
    var _modifies: Vocab_AdverbModifies = .verb
    var _comparativeForm: Vocab_ComparisonForms? = nil
    var _superlativeForm: Vocab_ComparisonForms? = nil
    var _isIrregularComparison: Bool = false

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _base = source._base
      _derivedFromAdjective = source._derivedFromAdjective
      _sourceAdjective = source._sourceAdjective
      _typicalPosition = source._typicalPosition
      _modifies = source._modifies
      _comparativeForm = source._comparativeForm
      _superlativeForm = source._superlativeForm
      _isIrregularComparison = source._isIrregularComparison
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._base) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._derivedFromAdjective) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._sourceAdjective) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._typicalPosition) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._modifies) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._comparativeForm) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._superlativeForm) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._isIrregularComparison) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._base {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._derivedFromAdjective != false {
        try visitor.visitSingularBoolField(value: _storage._derivedFromAdjective, fieldNumber: 2)
      }
      if !_storage._sourceAdjective.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sourceAdjective, fieldNumber: 3)
      }
      if _storage._typicalPosition != .beginning {
        try visitor.visitSingularEnumField(value: _storage._typicalPosition, fieldNumber: 4)
      }
      if _storage._modifies != .verb {
        try visitor.visitSingularEnumField(value: _storage._modifies, fieldNumber: 5)
      }
      try { if let v = _storage._comparativeForm {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._superlativeForm {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._isIrregularComparison != false {
        try visitor.visitSingularBoolField(value: _storage._isIrregularComparison, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vocab_FrenchAdverb, rhs: Vocab_FrenchAdverb) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._base != rhs_storage._base {return false}
        if _storage._derivedFromAdjective != rhs_storage._derivedFromAdjective {return false}
        if _storage._sourceAdjective != rhs_storage._sourceAdjective {return false}
        if _storage._typicalPosition != rhs_storage._typicalPosition {return false}
        if _storage._modifies != rhs_storage._modifies {return false}
        if _storage._comparativeForm != rhs_storage._comparativeForm {return false}
        if _storage._superlativeForm != rhs_storage._superlativeForm {return false}
        if _storage._isIrregularComparison != rhs_storage._isIrregularComparison {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vocab_Word: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Word"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "french_verb"),
    2: .standard(proto: "french_noun"),
    3: .standard(proto: "french_adjective"),
    4: .standard(proto: "french_adverb"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Vocab_FrenchVerb?
        var hadOneofValue = false
        if let current = self.wordType {
          hadOneofValue = true
          if case .frenchVerb(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.wordType = .frenchVerb(v)
        }
      }()
      case 2: try {
        var v: Vocab_FrenchNoun?
        var hadOneofValue = false
        if let current = self.wordType {
          hadOneofValue = true
          if case .frenchNoun(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.wordType = .frenchNoun(v)
        }
      }()
      case 3: try {
        var v: Vocab_FrenchAdjective?
        var hadOneofValue = false
        if let current = self.wordType {
          hadOneofValue = true
          if case .frenchAdjective(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.wordType = .frenchAdjective(v)
        }
      }()
      case 4: try {
        var v: Vocab_FrenchAdverb?
        var hadOneofValue = false
        if let current = self.wordType {
          hadOneofValue = true
          if case .frenchAdverb(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.wordType = .frenchAdverb(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.wordType {
    case .frenchVerb?: try {
      guard case .frenchVerb(let v)? = self.wordType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .frenchNoun?: try {
      guard case .frenchNoun(let v)? = self.wordType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .frenchAdjective?: try {
      guard case .frenchAdjective(let v)? = self.wordType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .frenchAdverb?: try {
      guard case .frenchAdverb(let v)? = self.wordType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vocab_Word, rhs: Vocab_Word) -> Bool {
    if lhs.wordType != rhs.wordType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vocab_GetRecentWordsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRecentWordsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "words"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.words) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.words.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.words, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vocab_GetRecentWordsResponse, rhs: Vocab_GetRecentWordsResponse) -> Bool {
    if lhs.words != rhs.words {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vocab_GetRecentWordsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRecentWordsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vocab_GetRecentWordsRequest, rhs: Vocab_GetRecentWordsRequest) -> Bool {
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
